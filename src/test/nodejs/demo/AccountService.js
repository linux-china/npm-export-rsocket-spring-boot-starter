// Don't edit this file because it was generated by Spring Boot App!!!
const {Observable} = require('rxjs');
const {Flowable} =  require('rsocket-flowable');
const {encodeAndAddWellKnownMetadata, MESSAGE_RSOCKET_ROUTING} = require('rsocket-core');
const {ReactiveSocket} = require('rsocket-types')

//const murmurhash3Seed = 104729;
const maxRSocketRequestN = 2147483647;

function requestMetadata(route) {
    return encodeAndAddWellKnownMetadata(
            Buffer.alloc(0),
            MESSAGE_RSOCKET_ROUTING,
            Buffer.from(String.fromCharCode(route.length) + route));
}

/**
 *  convert param to json Buffer
 * @param {Object|number|null} param
 * @return {Buffer|null}
 */
function toJsonBuffer(param) {
    if (param == null) {
        return null;
    } else if (typeof param == 'number') {
        return Buffer.from('' + param);
    } else if (typeof param == 'string') {
        return Buffer.from(param);
    } else {
        return Buffer.from(JSON.stringify(param))
    }
}

/**
 * @version 2020.04.02
 */
class AccountService {
    constructor() {
        this.serviceName = 'org.mvnsearch.user.AccountService';
    }

    /**
     * rsocket requestResponse
     * @param {string} methodName
     * @param {Object|number|null} [param]
     * @return {Promise<Object>}
     * @private
     */
    rsocketRequestResponse(methodName, param) {
        return this.promiseRSocket.then(rsocket => {
            return new Promise((resolve, reject) => {
                rsocket.requestResponse({
                    data: toJsonBuffer(param),
                    metadata: requestMetadata(this.serviceName + "." + methodName)
                }).subscribe({
                    onComplete: (value) => resolve(JSON.parse(value.data.toString())),
                    onError: error => reject(error)
                });
            });
        })
    }

    /**
     * rsocket fireAndForget
     * @param {string} methodName
     * @param {Object|number|null} [param]
     * @return {Promise<boolean>}
     * @private
     */
    rsocketFireAndForget(methodName, param) {
        return this.promiseRSocket.then(rsocket => {
            return new Promise((resolve, reject) => {
                rsocket.fireAndForget({
                    data: toJsonBuffer(param),
                    metadata: requestMetadata(this.serviceName + "." + methodName)
                }).subscribe({
                    onComplete: (value) => {
                        resolve(true)
                    },
                    onError: error => reject(error)
                });
            });
        })
    }

    /**
     * rsocket requestStream
     * @param {string} methodName
     * @param {Object|number|null} [param]
     * @return {Observable<Object>}
     * @private
     */
    rsocketRequestStream(methodName, param) {
        return new Observable(subscriber => {
            this.promiseRSocket.then(rsocket => {
                rsocket.requestStream({
                    data: toJsonBuffer(param),
                    metadata: requestMetadata(this.serviceName + "." + methodName)
                }).subscribe({
                    onComplete: () => subscriber.complete(),
                    onError: error => subscriber.error(error),
                    onNext: value => subscriber.next(JSON.parse(value.data.toString())),
                    onSubscribe: sub => sub.request(maxRSocketRequestN)
                });
            });
        })
    }

    /**
     * rsocket requestChannel
     * @param {string} methodName
     * @param {Array|Observable|Flowable} [param]
     * @return {Observable<Object>}
     * @private
     */
    rsocketRequestChannel(methodName, param) {
        let fluxData = null;
        if (Array.isArray(param)) {
            fluxData = Flowable.just(param);
        } else if (param instanceof Observable) {
            fluxData = new Flowable(subscriber => {
                param.subscribe({
                    next(x) {
                        subscriber.onNext(x);
                    },
                    error(err) {
                        subscriber.one(err);
                    },
                    complete() {
                        subscriber.onComplete();
                    }
                });
            });
        } else if (param instanceof Flowable) {
            fluxData = param;
        }
        return new Observable(subscriber => {
            this.promiseRSocket.then(rsocket => {
                rsocket.requestChannel(fluxData.map(data => {
                    return {
                        data: toJsonBuffer(data),
                        metadata: requestMetadata(this.serviceName + "." + methodName)
                    }
                })).subscribe({
                    onComplete: () => subscriber.complete(),
                    onError: error => subscriber.error(error),
                    onNext: value => subscriber.next(JSON.parse(value.data.toString())),
                    onSubscribe: sub => sub.request(maxRSocketRequestN)
                });
            });
        })
    }

    /**
     * set rsocket
     * @param {Promise<ReactiveSocket>} promiseRSocket
     * @returns {AccountService}
     */
    setPromiseRSocket(promiseRSocket) {
        this.promiseRSocket = promiseRSocket;
        return this;
    }
    /**
    *
    * @param {number} id
    * @return {Promise<org_mvnsearch_boot_npm_export_demo_Account>}
    */
    findById(id) {
      return this.rsocketRequestResponse('findById',id);
    }

    /**
    *
    * @param {string} nick
    * @return {Promise<org_mvnsearch_boot_npm_export_demo_Account>}
    */
    findByNick(nick) {
      return this.rsocketRequestResponse('findByNick',nick);
    }

    /**
    *
    * @return {Observable<org_mvnsearch_boot_npm_export_demo_Account>}
    */
    findAll() {
      return this.rsocketRequestStream('findAll');
    }

}

module.exports = new AccountService();

//================ JSDoc typedef ========================//
/**
* @typedef {Object} org_mvnsearch_boot_npm_export_demo_Account
* @property {number} id
* @property {string} nick
* @property {string} phone
* @property {string} password
* @property {number} status
*/
